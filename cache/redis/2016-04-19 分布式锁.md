# 设计要点：

* 锁的实效，避免被强制解锁，或者单点故障影响其他客户端获取锁；
* 可重入锁和吞吐量的权衡；
* 减少redis压力（减少获取锁的操作）；
* 加锁的事务尽量细粒度；
* 同步锁状态给其他客户端（分布式消息：类似线程的notifyAll）；
* 考虑执行句柄中的异常，状态的正确流转和状态。

# 设计细节

时间戳的设计有很多问题

## 通过一些java.util.concurrent的API来处理一些本地队列的同步以及等待信号量的处理

* Semaphore

* ConcurrentHashMap



